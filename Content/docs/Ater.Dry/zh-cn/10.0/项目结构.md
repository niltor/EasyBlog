# 项目模板说明

Ater.Web.template 是基于`ASP.NET Core`和`EntityFramework Core`技术栈的项目模板，提供了开箱即用的项目结构和基础功能，帮助开发者快速搭建一个现代化的Web应用程序。

本着以结果为导向，实用为目标，在架构设计上，我们主要追求**通用、简洁和灵活**三个原则，致力于为开发者提供高效且易用的开发体验，先简要说明这三个目标：

- 通用：指尽可能使用主流的，官方的，已被大量采用或认可的技术栈和实现方式，以避免不必要的学习成本。
- 简捷：简单和快捷。指保持代码和结构的简单，在使用上快捷。尽可能降低心智负担，避免过度设计和不必要的抽象。专注于业务逻辑实现，减少重复性代码内容。
- 灵活：我们在通用、简捷的基础上提供约定和最佳实践，这是非侵入式的，由于我们并不以某些设计模式或开发习惯为目标，开发者不需要受其限制。

为了达成这样的目标，我们将项目开发分成两个部分：`框架层`与`项目层`。

## 框架层(Framework)

在框架层指的是经过多个项目的经验积累，总结出来的最佳实践和约定。这些约定符合`通知、简捷、灵活`的原则，旨在帮助开发者快速上手和理解项目结构，并能够基于此，快速实现业务逻辑代码。

我们将通过提供以下程序集来实现框架层的功能：
  
- Framework.Common：基础类库，包含一些常用的扩展方法和工具帮助类。
- Framework.Web.Convention：Web开发相关的约定，通过接口定义。
- Framework.Web.Extension：在Web开发中常用的三方类库集成，如发邮件，图形验证码，Excel导出等。

由于框架层与项目和业务无关，它们可以被打包成类库，为此我们提供了打包后的Nuget包，你也可以直接使用：

- Ater.Common
- Ater.Web.Convention
- Ater.Web.Extension

## 项目层

项目层其实是为了与框架层区分，指与本项目相关的层级结构，主要包括：

- **Definition**，定义层，用来定义业务模型
- **Implement**，实现层，用来实现业务逻辑
- **Services**，服务层，对外提供接口服务

这是一个通用的流程，非常容易理解，对于各个行业的流程，我们都可以抽象出这三个步骤：**定义->实现->服务**。

- **定义** 是要搞清楚我们要做什么，需要什么，产出什么。
- **实现** 是指具体的实现过程，将我们的有的资源，转换成产出结果的过程。
- **服务** 就像一个用户代理，接收用户需求，根据需求将对应的产出结果交给用户。

## 定义层(Definition)

定义层，定义业务模型，决定了业务的数据模型和行为，是业务实现的基础和前提，通常包括：

- **Entity**:实体定义，决定核心业务模型的存储结构。
- **EntityFramework**：ORM映射定义，决定实体与数据库表的映射关系。
- **Share**：一些可共享的模型内容，如DTO，Options等。
- **ServiceDefaults**：通用服务注入的定义，如健康检查，重试机制，日志等。

## 实现层(Implement)

实现层，主要是实现业务逻辑。

在实际需要中，业务需求常常涉及多个领域或多个业务模块，我们可以按照业务模块进行拆分，同时我们提供一个基础的共享模块，供各个业务模块使用。

典型结构如下:

- SharedModule：共享模块，供各个业务模块使用。
  - SharedModule.Implement：提供默认的实现，如ManagerBase，RestControllerBase等。
  - SharedModule.Services：通用的第三方服务封装，如邮件，消息队列服务等。
  - SharedModule.Managers：Manager是业务逻辑的核心，负责处理业务逻辑和数据交互。
- CustomerModule：客户模块，包含客户相关的业务逻辑。
- OrderModule：订单模块，包含订单相关的业务逻辑。

## Manager

在实际开发中，主要通过`Manager`实现业务逻辑。提供了`ManagerBase`实现类，该类主要提供了默认的数据访问的能力。

### EntityManager

最常见的用法是继承`ManagerBase<TEntity>`，其中`TEntity`对应一个业务实体模型，用来对该实体进行操作，称之为**EntityManager**。

通常**EntityManager**之间不会直接通过依赖注入进行互相调用，避免产生循环依赖。

### ManagerBase

并非所有Manager都是`EntityManager`，有些Manager可能并不专门用来操作某个实体，这时可以直接继承`ManagerBase`，并实现自己的业务逻辑。

```csharp
/// <summary>
/// Manager base without entity
/// </summary>
/// <param name="logger"></param>
/// <param name="dataAccessContext">数据访问上下文</param>
public class ManagerBase(DataAccessContext dataAccessContext, ILogger logger)
{
    protected readonly ILogger _logger = logger;
    protected CommandDbContext CommandContext { get; init; } = dataAccessContext.CommandContext;
    protected QueryDbContext QueryContext { get; init; } = dataAccessContext.QueryContext;
}
```

请注意，这里注入了`DataAccessContext`，它是一个数据访问上下文，包含了`CommandDbContext`和`QueryDbContext`两个上下文。

`ManagerBase`提供了对数据访问的支持，如果你的业务逻辑不涉及到数据状态的变化，建议将其封装成一个`Service`，而不是一个`Manager`。




## 服务层

对外提供服务的层，通常包括以下内容：
