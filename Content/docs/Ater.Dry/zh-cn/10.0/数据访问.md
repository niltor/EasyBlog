# 数据访问

数据库是应用服务开发的基础与核心。框架本身使用`Entity Framework Core`作为数据访问的ORM框架，提供了对数据库的访问能力。


使用`Entity Framework Core`不仅仅是为了方便，更重要的是规范了数据开发和访问的方式。

我们以`Code First`的方式来定义数据模型，然后使用`DbContext`来访问数据库。

## 读写分离

框架默认提供了`CommandDbContext`和`QueryDbContext`两个`DbContext`，分别用于数据的读和写操作。

我们抽象了一层`DataAccessContext`，并提供了`ManagerBase<TEntity>`基础类来使用`DataAccessContext`中的`CommandContext`和`QueryContext`。

对于常见的开发需求，我们只需要继承`ManagerBase<TEntity>`，优先使用父类提供的方法即可，并不用关心使用的是`CommandContext`和`QueryContext`，查询会默认使用`QueryContext`，并且不会追踪，即默认使用`AsNoTracking()`，而对于数据的增删改操作，会默认使用`CommandContext`。代码示例:

```csharp
public class CustomerInfoManager(
    DataAccessContext<CustomerInfo> dataContext,
    ILogger<CustomerInfoManager> logger
    ) : ManagerBase<CustomerInfo>(dataContext, logger)
{
}
```

当然你也可以直接使用`CommandContext`和`QueryContext`，来实现更复杂的操作，但你要自己处理不同上下文的数据追踪问题。

> [!IMPORTANT]
> 如果一个业务实现仅为查询，请使用`QueryContext`。
> 
> 如果业务实现涉及多种操作，为了避免不同上下文的冲突，可仅使用`CommandContext`来实现所有的操作。
>

## 使用指定数据库上下文

`DataAccessContext<TEntity>` 会默认使用`CommandDbContext`和`QueryDbContext`，如果你需要在Manager使用其他的数据库上下文，可以继承不同的父类，如:

```csharp
public class TestManager(
    OrderCommandDbContext commandDb,
    OrderQueryDbContext queryDb,
    ILogger<TestManager> logger)
    : ManagerBase<OrderQueryDbContext, OrderCommandDbContext, Order>(queryDb, commandDb, logger)
{
}
```

或者仅使用一个数据库上下文，如:

```csharp
public class TestManager(
    OrderDbContext dbContext,
    ILogger<TestManager> logger)
    : ManagerBase<OrderDbContext, Order>(dbContext, logger)
{
}
```

## 不使用数据库上下文或实体

如果你的Manager不涉及到数据库的操作，或者不局限于特定的实体，可以继承`ManagerBase`，然后注入使用自己的`DbContext`即可。

```csharp
public class TestManager(MyDbContext context, ILogger<TestManager> logger)
    : ManagerBase(logger)
{
}
```

> [!TIP]
> 继承`ManagerBase`的类，将会自动注入到`ServiceCollection`中。

## 租户模式

在有些场景下，应用需要支持多租户，比如SaaS应用。不同的租户使用不同的数据库，这样可以保证数据的隔离性。也能为不同租户提供不同的功能和服务。

框架默认提供了`ITenantProvider`接口来获取租户信息。

开发者需要使用租户信息，来构建`DbContext`，框架提供了`TenantDbFactory`类来根据租户信息来创建`DbContext`。要实现基于租户的`Manager`，要注入`TenantDbContextFactory`并继承`ManagerBase`即可， 示例代码如下:

```csharp
public class TestManager(TenantDbContextFactory factory, ILogger<TestManager> logger)
    : ManagerBase<User>(factory, logger)
{
}
```

> [!TIP]
> 你可以根据实际需求修改`TenantDbFactory`中的创建数据库上下文的逻辑。


## 多库操作

当你的逻辑需要操作多个数据库时，可以注入`DbContextFactory`服务，然后操作不同的数据库。

```csharp
public class TestManager(
    DbContextFactory dbFactory,
    ILogger<TestManager> logger)
    : ManagerBase<User>(factory, logger)
{

    public async Task MultiDatabase()
    {
        var mssqlDb = dbFactory.CreateDbContext<CommandDbContext>();
        mssqlDb.Database.SetCommandTimeout(30);
        var tenant = await mssqlDb.Tenants.FirstOrDefaultAsync();


        var pgsqlDb = dbFactory.CreateDbContext<QueryDbContext>(DatabaseType.PostgreSql);
        pgsqlDb.Database.SetCommandTimeout(30);
        var user = await pgsqlDb.Tenants.FirstOrDefaultAsync(u => u.TenantId == tenant.TenantId);
    }
}
```
> [!NOTE]
> 多库操作难以保证数据的一致性，耦合性较高，业务理解复杂，应尽量避免该情况。建议通过服务间调用，或使用消息队列来实现跨库操作，以保持最终一致性。